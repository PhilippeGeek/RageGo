{"name":"RageGo","tagline":"Rapport Final (French only sorry)","body":"# Introduction\r\nCe document a pour vocation d’offrir une vue générale au lecteur du logiciel libre “RageGo, a Role-Play and Aesthetic Game Engine for Go”, créé par Philippe VIENNE et Benoit RENAULT dans le cadre d’un projet de fin de classe prépartoire à l’INSA de Lyon. Afin de connaître dans le détail toutes les fonctionnalités du programme, il sera nécessaire de se référer à la documentation disponible sur http://doc.ragego.com/ (anglais). Il est également possible de consulter les sources du logiciel ainsi que des assets sur https://github.com/RageGo.\r\n# Cahier des charges\r\nComme son nom l’indique, ce programme a pour vocation d’apporter sa pierre à l’édifice des implémentations logicielles de jeux de go, en fournissant un moteur de jeu alternatif ainsi qu’une interface graphique d’un style nouveau. A longue échéance, un mode aventure permettra à l’utilisateur de découvrir cet ancien jeu sous un nouveau jour, plus moderne et proche des attentes et exigences des joueurs actuels. Nous reviendrons sur cela dans la partie “Futur du Projet”.\r\n\r\nAinsi, on comprendra que le développement de ce logiciel s’inscrit dans une démarche prévue sur le long terme, et nous en présenterons ici la version 0.2-rc dans laquelle nous avions prévu l’implémentation des fonctionnalités suivantes :\r\n\r\n* Être une application réellement multi-plateforme \r\n    * Supporter Windows, Mac, Linux & Android\r\n    * Garder le code potentiellement compatible IOS, HTML5 et BlackBerry\r\n* Posséder une interface utilisateur originale et spécialement adaptée\r\n    * Designer l’interface, créer les assets et les packager\r\n    * Adopter une approche axée données pour faciliter l’ajout de contenu et améliorer les performances (usage des textureAtlas et Skins de LibGDX)\r\n* Représenter le terrain de jeu selon un point de vue 3D isométrique (ou 2.5D)\r\n    * Adopter une approche axée données pour faciliter l’ajout de contenu (format de map .tmx)\r\n    * Gérer les différents systèmes d’entrée (écran, souris, clavier) pour transmettre les coordonnées d’un coup dans le référentiel du moteur de jeu\r\n    * Faciliter la future intégration des terrains de jeu dans le futur monde virtuel du mode aventure\r\n* Être capable de calculer et jouer une partie de jeu de Go\r\n    * Représenter un jeu de Go sous la forme d’objets informatique\r\n    * Implémenter un set de règles de jeu de Go cohérentes\r\n    * Permettre une édition dynamique du plateau de jeu (retour en arrière, avant, passer son tour…)\r\n    * Gérer le plateau de jeu indépendamment de la partie graphique de manière performante (usage d’un thread dédié)\r\n    * Calculer l’influence des pierres de chaque joueur en fin de partie et en déduire automatiquement le score\r\n    * Prévoir la futur implémentation de l’IA et des coups spéciaux (triche) qu’elle pourra faire\r\n* Supporter le format .sgf (standard game format)\r\n    * Permettre la sauvegarde sur PC en jeu d’une partie\r\n    * Permettre l’usage de parties déjà jouées et scorées à des fins de test unitaires uniquement\r\n* Créer des tests unitaires pour le moteur de jeu\r\n    * Donner un moyen de contrôler en permanence la viabilité de l’ajout de nouveau code (cf. Travis, https://travis-ci.org/RageGo/RageGo)\r\n    * Vérifier la justesse de l’implémentation des règles et du calcul de score\r\n* Implémenter un menu principal\r\n    * Permettre l’accès aux différents modes de jeu\r\n    * Prévoir l’ajout des futures fonctionnalités\r\n* Implémenter le mode multijoueur local (1vs1)\r\n    * Implémenter les fonctionnalités de sauvegarde et édition du plateau de jeu\r\n    * Afficher les nombres de pierres adverses capturées à tout instant de la partie\r\n    * Offrir une ébauche d’interface de pré-paramétrage du terrain de jeu dont la taille et l’apparence seront réglables\r\n* Implémenter une ébauche du mode de jeu multijoueur en ligne (1vs1, chronométré)\r\n    * Implémenter un serveur stockant de façon temporaire les données à échanger (Ruby On Rails, voir http://github.com/RageGo/server)\r\n    * Gérer les utilisateurs au moyen de clefs uniques\r\n    * Utiliser le protocole HTTP pour permettre une connexion dans la majorité des circonstances réseau (ex: proxy universitaire)\r\n    * Vérifier la disponibilité de la connexion en tâche de fond de façon régulière (thread dédié)\r\n    * Limiter les possibilités d’édition de la carte (pas de retours avant/arrière)\r\n    * Affecter une durée limite aux tours de chaque joueur pour éviter les cas d’inactivité prolongée\r\n\r\n# Problèmes et solutions\r\nÉtant donné le nombre de problématiques que nous avons rencontré lors du développement, nous évoquerons chacun plutôt quelques morceaux choisis nous ayant plus particulièrement marqué. Ainsi, le lecteur bénéficiera d’un aperçu de notre cheminement sans pour autant se perdre dans des méandres de détails.\r\n## Philippe parle : “Le moteur et le réseau”\r\n### Calcul du jeu\r\nLe calcul du jeu est un problème que l’on a au départ largement sous-estimé. En effet le jeu de Go a des règles simples mais assez floues d’un point de vue informatique et il est donc difficile de les faire valider par un ordinateur. D’autre part il était aussi important pour nous que le calcul soit le plus optimal possible, le jeu devant fonctionner même sur un smartphone ayant peu de puissance de calcul.\r\n\r\nPour ajuster l’interprétation des règles, j’ai donc créé des petits fichiers de test en .sgf pour les données et dès qu’un test passait, c’était que la règle testée dans le fichier était valide. Cela a impliqué de commencer par implémenter la lecture du format .sgf puis de valider celle-ci pour pouvoir écrire les vérifications des règles.\r\n### Transmissions des coups par le réseau\r\nLe jeu en réseau implique que deux ordinateurs se transmettent les données du jeu à calculer. L’idéal pour ce genre de problématique serait qu’un serveur reçoive une donnée en entrée et donne le résultat au deux joueurs. Cependant dans notre contexte et avec les technologies que nous choisies ce n’était pas le plus adapté.\r\n\r\nJ’ai donc opté pour une solution s’inspirant du format .sgf, c’est à dire que je décris la partie sous la forme d’un arbre où chaque noeud est un coup joué dans le jeu. Le jeu est ainsi représenté par une succession de coups qui nous permettent de recalculer l’état du jeu. Afin de garantir que le calcul du jeu est exact, un hash md5 de la situation du plateau est aussi fourni dans le noeud. Les ordinateurs n’ont donc plus qu’à se transmettre les noeuds par le biais du serveur. Afin de faciliter le transfert, les noeuds sont transformés en chaînes de caractères sérialisées.\r\n### Calcul du score\r\nLe calcul du score au jeu de go n’est pas chose aisée, car il faut déterminer à la fois le nombre de pièces capturés par l’adversaire mais en plus les territoires conquis, ce dernier point étant le plus compliqué.    Afin de faire cela, j’ai utilisé un algorithme A* pour établir le propriétaire d’une zone. Cependant cela a causé un autre problème car une pierre du joueur noir peut se trouver isolé dans une grande zone blanche. Or dans ce cas l’algorithme en A* n’est pas suffisant pour trancher sur la propriété de territoire.\r\n### Calcul de l’influence\r\nLe calcul d’influence est un élément qui s’est révélé être essentiel dans le cadre du calcul du score. En effet, à la fin d’une partie réelle, les deux joueurs se mettent directement d’accord sur les pièces à enlever en fin de partie car le fait de constater qu’une pièce est morte est une tâche assez facile pour un cerveau humain. Cependant, on est obligé dans le cadre d’un programme de lui donner une règle stricte pour estimer une pierre comme morte. C’est ici que l’influence entre en jeu : on peut considérer une pièce perdue si l'adversaire a dessus une plus grande influence que le joueur.\r\n\r\nPour les règles de calcul de cette influence, je me suis référé à l’algorithme présenté par GNU Go (cf. Bibliographie). Cependant, afin de l'appliquer à notre jeu, les constantes de départ ont du être déterminées par un processus expérimental itératif.\r\n### La connexion Moteur/Graphique\r\nMalgré tous nos efforts pour améliorer la performance du moteur de jeu, nous nous sommes retrouvés face à un problème de concurrence des actions, l’ordinateur ne pouvant pas effectuer le rafraîchissement graphique tant qu’il est en train de calculer la partie.\r\n\r\nLa solution a donc été de travailler dans des Threads Java différents : de cette façon, le thread du jeu attend une entrée de l’utilisateur puis calcule de son coté sans gêner la partie graphique et ensuite appelle celle-ci pour lui donner les pièces à ajouter et à enlever. On a du aussi développer la même technique pour le mode en ligne afin d’attendre les valeurs du serveur.\r\n## Benoit parle : “La Game User Interface”\r\n### Coordonnées écran → isométriques → goban (terrain de jeu)\r\nLa première problématique qui s’est posée dès le début du projet, puisque l’on souhaitait alors déjà réaliser l’affichage du plateau de jeu sous la forme d’une terrain en 3D isométrique, a été de trouver un moyen de transformer le clic de l’utilisateur sur l’écran en une coordonnée que le moteur de jeu puisse accepter.\r\n    \r\nTout d’abord, il faut savoir que LibGDX possède des notions de programmation de jeu avancées comme le concept de différentiation entre coordonnées du monde et coordonnées de l’écran. Pour bien le comprendre, dans le cas 2D qui nous intéresse ici, il suffit de visualiser un plan infini imaginaire sur lequel vous placez vos éléments graphiques, leur taille en pixels étant égale à leur taille en unités de longueur de ce monde virtuel. Imaginez maintenant une caméra qui va se déplacer à la surface de ce plan et filmer donc tout ce qu’elle voit dans son champ de vision. Cette caméra transmet ce qu’elle voit à l’écran, qui va alors les afficher en utilisant le ratio entre unités de l’écran et unités du monde approprié. Ainsi, de la même manière on peut projeter des coordonnées de l’écran en coordonnées du monde avec des fonctions natives de LibGDX. Et ceci est le point de départ vers l’implémentation de la conversion.\r\n\r\nLe coin gauche de la carte étant placé en l’origine du plan imaginaire, l’origine du repère orthonormal est confondue avec celle du repère isométrique de la carte, qui a en fait la forme d’un parallélogramme. La première méthode que j’ai donc développé était un changement de repère du premier vers le second, ce qui se faisait moyennant quelques calculs de trigonométrie. Néanmoins, devoir faire appel à des fonctions mathématiques comme arctangente à chaque changement de coordonnées n’était guère excellent d’un point de vue performance (La méthode est toujours disponible dans le code mais en @Deprecated). Après de plus amples recherches sur le web, j’ai trouvé cet excellent article écrit par Clint Bellanger, développeur du jeu en 3D isométrique “Flare” : http://clintbellanger.net/articles/isometric_math/.\r\n\r\nEn adaptant légèrement les équations qu’ils présentait (pivotement du repère et déplacement de l’origine de la case en son centre), j’ai pu créer une nouvelle méthode alternative, bien plus économe en ressources. Finalement, l’origine du goban dépendant des coordonnées où la personne créant la carte la peint, en ajoutant une propriété au fichier de la carte, il était enfin possible de translater la coordonnée voulue dans le système de coordonnées du Goban, et de rendre ainsi la communication entre l’utilisateur et la partie “Engine” possible.\r\n\r\nPour voir le code :\r\nhttps://github.com/RageGo/RageGo/blob/master/core/main/java/com/ragego/utils/GuiUtils.java\r\n\r\n\r\n# Structuration des données\r\nLe nombre de classes de l’application étant assez conséquent, nous ne ferons dans cette partie qu’une rapide description globale de leur hiérarchie, et nous vous inviterons à consulter le diagramme UML (http://uml.ragego.com) ainsi que la JavaDoc (http://doc.ragego.com) du projet afin de comprendre plus en détail.\r\n\r\nLe projet se divise d’abord en deux sous-projets, l’un “desktop”, l’autre “android”, contenant les spécifications particulières aux deux systèmes. Le second contient également  les assets du jeu (images, fonts, musiques….) pour des raisons de compatibilités. Vient ensuite leur dépendance “core” qui comme son nom l’indique, contient tout le “code” à proprement parler.\r\n\r\nCelle-ci est constituée d’un dossier “main” et d’un dossier “test”, l’un contenant les classes servant à faire fonctionner le projet, l’autre contenant les tests unitaires. Les deux partagent la même hiérarchie interne et pour “main” on a :\r\n* com.ragego.engine contient toutes les classes relatives à l'implémentation du jeu de go en elle-même. Elle contient plusieurs types d’objets, tout d’abord :\r\n    * GameBoard, Stone, StoneGroup et Shape qui sont les classes qui représentent les objets d’un jeu de go et disposent des méthodes adéquates pour les manipuler.\r\n    * GameNode qui représente un coup.\r\n    * Player, IAPlayer, HumanPlayer qui sont les classes définissant un joueur, les deux dernières étant les filles de la première.\r\n* TurnListener et GameListener qui permettent respectivement d’écouter les tours ou alors tous les évènements d’un jeu.\r\n* Les autres classes sont plus à considérer comme des aides pour certains aspects qui étaient plus évidents à extraire comme des classes.\r\n* com.ragego.gui contient trois packages dont les classes étendent pour la plupart directement des classes de LibGDX à l’exception du package objects. Ceux-ci définissent tout l’aspect graphique du jeu.\r\n* com.ragego.network contient toutes les classes non-graphiques relatives à la gestion du mode online.\r\n* com.ragego.utils permet quant à lui d’externaliser diverses méthodes généralement statiques qui sont utilisées par d’autres packages. L’intérêt est d’alléger les autres packages de ces méthodes et classes. Il contient également tous nécessaire pour l’import/export de fichiers .sgf.\r\n\r\n# Futur du projet\r\nVous trouverez ci-dessous les prospections futures pour le jeu dans l’ordre du plus court-terme, au plus long-terme.\r\n## Partage avec la communauté\r\n\r\nComme exprimé dans l’introduction, notre intention est de produire un jeu libre : le code est sous licence GNU GPL v.3, et tous les assets sont disponibles sous licence Creative Commons By-SA 3.0. L’idée est un peu de “rendre” à la communauté du libre ce qu’elle nous a donné (LibGDX est sous licence libre Apache 2.0). Cela est d’autant plus intéressant que le nombre de jeux libres est peu important, et que notre application contribue à remplir ce manque.\r\n    \r\nLe premier aspect d’intérêt avec le fait de produire un logiciel libre et gratuit est que les barrières pour l’utiliser sont quasi-inexistantes, d’autant plus que le jeu est disponible sur de nombreuses plateformes et que son téléchargement est facile d’accès (ex : application sur le Play Store d’Android). Ainsi cela devrait contribuer à le rendre plus connu, et plus rapidement. Il est d’ailleurs prévu à court terme (vacances d’été à venir) de mettre en place le site web, ainsi qu’envoyer quelques propositions de brèves sur des sites spécialisés afin d’attirer l’attention sur le jeu.\r\n\r\nL’autre aspect intéressant de faire un jeu libre, c’est que tout le monde peut proposer une contribution au projet, et nous espérons qu’au fur et à mesure que celui-ci prendra de l’ampleur, de plus en plus de personnes viendront apporter leur pierre à l’édifice et créer ainsi une expérience de jeu mémorable. C’est d’ailleurs à cet effet qu’un bouton “Crédits” est présent sur le menu principal afin de créditer tous les futurs contributeurs.\r\n## Mode aventure\r\n\r\nUne des spécifications du jeu qui nous tient le plus à coeur et qui fera sûrement l’objet de la prochaine mise à jour majeure, est le mode Aventure. L’idée est de développer une véritable couche Role-Play, où le joueur sera amené à incarner un personnage devant accomplir des quêtes, résoudre des énigmes et parcourir des donjons qui lui permettront d’apprendre à jouer au jeu de Go et de s’entraîner contre des intelligences artificielles sans que cet exercice ne soit perceptible. En résumé, créer un véritable RPG où les mécaniques de combat et de réflexion usuelles seraient remplacées par des énigmes et parties de jeu de Go scénarisées.\r\n    \r\nCe mode est d’ailleurs déjà en quelque sorte partiellement implémenté, ou du moins les outils et technologies nécessaires le sont : le fonctionnement par map, les texturesAtlas, les Skins, tous sont déjà là, et fonctionnels. Le contenu, lui, sera sûrement au final ce qui prendra le plus de temps à faire (les scénarios, les ambiances, les assets, les musiques…).\r\nLobby pour le mode multijoueur en ligne\r\n\r\nLa version actuelle des écrans de configuration des modes multijoueur est temporaire. Il sera nécessaire, au fur et à mesure que le jeu grandira de les redéfinir et de les étoffer avec de nouvelles options. Notamment, pour le mode en ligne, la création d’un lobby de connexion avec une zone de dialogue pour que des joueurs ne se connaissant pas puisse jouer ensemble sans avoir à en convenir sur un support extérieur (forum, réseau social…) est une feature qu’il sera important d’implémenter. Un support des serveurs déjà populaires de jeux de go en ligne comme le KGS serait un plus non négligeable pour attirer de nouveaux joueurs.\r\n# Bibliographie\r\nNote : Ne contient que les éléments d’importance majeure.\r\n## LibGDX\r\n\r\nBALAKRISHNAN NAIR Suryakumar, OEHLKE Andreas. Learning LibGDX Game Development. 2nd Ed. Birmingham, UK : PackPublishing, 2015, 478p. ISBN 9781783554775\r\nUn livre de référence sur LibGDX, écrit par deux développeurs et utilisateurs très actifs du moteur. Constitue une excellente ressource pour tous niveaux, même si une connaissance de Java est un plus particulièrement appréciable.\r\n\r\nSALTARES MARQUEZ David, CEJAS SANCHEZ Alberto. Libgdx Cross-platform Game Development Cookbook. Birmingham, UK : PackPublishing, 2014, 516p. ISBN 9781783287291\r\nUn livre de référence sur LibGDX, écrit par deux développeurs et utilisateurs très actifs du moteur. Constitue une excellente ressource pour ceux ayant déjà de solides notions de Java, et ayant déjà touché au développement de jeux-vidéos.\r\n\r\nLIBGDX COMMUNITY. LibGDX Github Wiki Homepage [En ligne]. Disponible sur : \r\nhttps://github.com/libgdx/libgdx/wiki (consulté le 01/06/2015)\r\nUne véritable mine d’informations sur le moteur de jeu LibGDX. Particulièrement utile pour des recherches sur la façon d’utiliser une fonction particulière, ou comprendre la manière dont fonctionne une technologie.\r\n\r\nLIBGDX COMMUNITY. LibGDX JavaDoc [En ligne]. Disponible sur :\r\nhttp://libgdx.badlogicgames.com/nightlies/docs/api/ (consulté le 01/06/2015)\r\nCette interface est particulièrement pratique pour consulter la JavaDoc de LibGX. S’utilise en complément de recherche quand le wiki ou les livres ne suffisent plus.\r\n\r\nGAMEFROMSCRATCH. LibGDX Tutorial series [En ligne]. Disponible sur :\r\nhttp://www.gamefromscratch.com/page/LibGDX-Tutorial-series.aspx (consulté le 01/06/2015)\r\nUn site web proposant de bons tutoriels pour commencer à manipuler LibGDX. On y trouve notamment quelques exemples d’utilisation de TiledMaps donnant un aperçu des pratiques possibles.\r\n## Tiled\r\n\r\nLINDEIJER Thorbjørn. Tiled Github Wiki Homepage [En ligne]. Disponible sur : \r\nhttps://github.com/bjorn/tiled/wiki (consulté le 01/06/2015)\r\nUne référence incontournable pour comprendre correctement le fonctionnement du format .tmx et du logiciel Tiled. Le forum disponible sur le site mère est aussi d’une grande aide dans la résolution de problème particuliers.\r\n\r\n## Jeu de Go\r\n\r\nSENSEIS COMMUNITY. Standard Go Format [En ligne]. Disponible sur : http://senseis.xmp.net/?SGF (consulté le 01/06/2015)\r\nDescription du format .sgf pour stocker les parties.\r\n\r\nGNUGO PROJECT. The Influence Function [En ligne]. Disponible sur : http://www.gnu.org/software/gnugo/gnugo_13.html (consulté le 01/06/2015)\r\nDescription de la fonction d’influence du jeu de Go\r\n\r\nWIKIPEDIA COMMUNITY. Go (Game) [En Ligne]. Disponible sur : http://en.wikipedia.org/wiki/Go_%28game%29 (consulté le 01/06/2015)\r\nExplication du jeu de Go et description complète des règles.\r\n\r\nGITHUB DEVELOPPER DTOPLIN. CountScore.java [En ligne] Disponible sur : https://github.com/dtolpin/uct/blob/master/codes/gogui-1.4.2/src/net/sf/gogui/go/CountScore.java (consulté le 01/06/2015)\r\nExemple de décompte du score en Java pour une partie de jeu de Go. Cela a été utile pour l’utilisation de la fonction d’influence.\r\n\r\nDRAGO COMMUNITY. Drago (software) [En ligne] Disponible sur : http://www.godrago.net/ (consulté le 01/06/2015)\r\nÉdition de fichiers .sgf pour les tests unitaires.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}